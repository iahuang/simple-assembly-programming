.start x86init
labelnull: nop
; x86 general registers
eax: .integer #3
ebx: .integer #0
ecx: .integer #0
edx: .integer #0
esi: .integer #0
edi: .integer #0

; x86 sepcial registers
esp: .integer #0
ebp: .integer #0

; emulator binary registers (for bitwise operations)
bin1: .allocate #32
bin2: .allocate #32

endl: .integer #1
    .integer #10

tobinary:
    ; r1 is the value
    ; r2 is the pointer to the bytedump
    ; r5 is a copy of r1
    ; r6 is the remainder
    ; r7 is the number of bits computed
    ; r8 is r1 / 2
    clrr r7
    movir #32 r9
    clrb r2 r9
    cmpir #0 r1
    jmpz tobinret

    addir #32 r2
biniter:
    movrr r1 r5
    divir #2 r1
    movrr r1 r8
    mulir #2 r1
    cmprr r1 r5
    movrr r8 r1
    clrr r6
    jmpne remainder1 ; if remainder is 1
    jmpz remainder0 ; if remainder is 0
remainder1:
    movir #1 r6
remainder0:
    cmpir #0 r5
    jmpz endbin
    push r6
    addir #1 r7

    jmp biniter

endbin:
    subrr r7 r2
ebiniter:
    pop r6
    movrx r6 r2
    addir #1 r2
    subir #1 r7
    cmpir #0 r7
    jmpne ebiniter
tobinret:
    ret

power:
    ; r0 a^b
    ; r1 a
    ; r2 b
    movir #1 r0
    cmpir #0 r2
    jmpz endpower
poweriter:
    mulrr r1 r0
    subir #1 r2
    cmpir #0 r2
    jmpne poweriter
endpower:
    ret

todecimal:
    ; r0 total
    ; r1 pointer to the bytedump
    ; r5 the exponent
    ; r6 digit term (n*2^x)

    addir #31 r1
    clrr r0
    clrr r5

todeciter:
    movxr r1 r6
    push r1
    push r2
    push r0
    movir #2 r1
    movrr r5 r2
    jsr power
    mulrr r0 r6

    pop r0
    pop r2
    pop r1

    addrr r6 r0    
    
    addir #1 r5
    subir #1 r1

    cmpir #32 r5
    jmpne todeciter

    ret

low16:
    ; r1 address of Nx register where N is a-d
    call tobinary *r1 &bin2

    movar bin1 r5
    movir #16 r6
    clrb r5 r6

    movar bin1 r1
    jsr todecimal
    ret

high8:
    ; r1 address of eNh register where N is a-d

    call tobinary *r1 &bin2

    movar bin1 r5
    addir #16 r5
    movrr r5 r6
    addir #8 r6
    movir #8 r7

    movb r5 r6 r7

    movar bin1 r5
    movir #24 r6
    clrb r5 r6

    movar bin1 r1
    jsr todecimal

    ret

low8:
    ; r1 address of Nl register where N is a-d
    call tobinary *r1 &bin1 

    movar bin1 r5
    movir #24 r6
    clrb r5 r6

    movar bin1 r1
    jsr todecimal
    ret

setlow16:
    ; r1 address of Nx register where N is a-d
    ; r2 is the new value

    call tobinary *r1 &bin1
    call tobinary r2 &bin2

    movar bin2 r5
    movar bin1 r6
    addir #16 r5
    addir #16 r6
    movir #16 r7
    movb r5 r6 r7

    call todecimal &bin1
    movrx r0 r1
    
    ret

setlow8:
    ; r1 address of Nx register where N is a-d
    ; r2 is the new value

    call tobinary *r1 &bin1
    call tobinary r2 &bin2

    movar bin2 r5
    movar bin1 r6
    addir #24 r5
    addir #24 r6
    movir #8 r7
    movb r5 r6 r7

    call todecimal &bin1
    movrx r0 r1
    
    ret

sethigh8:
    ; r1 address of Nx register where N is a-d
    ; r2 is the new value

    call tobinary *r1 &bin1
    call tobinary r2 &bin2

    movar bin2 r5
    movar bin1 r6
    addir #24 r5
    addir #16 r6
    movir #8 r7
    movb r5 r6 r7

    call todecimal &bin1
    movrx r0 r1
    
    ret

x86push:
    ; r1 value
    addim #1 esp
    movmr esp r4
    movrx r1 r4
    ret

x86pop:
    movmr esp r4
    movxr r4 r0
    subim #1 esp
    ret

x86ret: ; Uses code manipulation to jump to a custom location
    call x86pop
    movar retval r4
    addir #1 r4
    movrx r0 r4
retval:
    jmp labelnull

test:
    movar eax r1
    jsr low8
    printi r0
    outs endl
    call sethigh8 &eax #122
    movmr eax r6
    printi r6
    outs endl
    
Ufinal:
    .allocate #4

x86init:
    movar L_.str r1
    movrm r1 Uhmm
    movar programend r1
    addir #100 r1
    movrm r1 esp
    movar end r2
    addir #2 r2
    call x86push r2
end:
    jmp Umain
    halt 

Uprint:
    movmr ebp r1
    call x86push r1
    
    movmr esp r1
    movar ebp r2
    movrx r1 r2
    
    movar ebp r1
    call x86pop
    movrx r0 r1
    
    call x86ret
    
Uprinti:
    movmr ebp r1
    call x86push r1
    
    movmr esp r1
    movar ebp r2
    movrx r1 r2
    
    movar ebp r1
    call x86pop
    movrx r0 r1
    
    call x86ret
    
Umain:
    movmr ebp r1
    call x86push r1
    
    movmr esp r1
    movar ebp r2
    movrx r1 r2
    
    movmr edi r1
    call x86push r1
    
    movmr esi r1
    call x86push r1
    
    push r2
    movar checkpoint0 r2
    addir #2 r2
    call x86push r2
    pop r2
checkpoint0:
    jmp L2Dpb
    
L2Dpb:
    movar ecx r1
    call x86pop
    movrx r0 r1
    
    movmr ecx r3
    movar Un r4
    addrr r4 r1
    movar L2Dpb r5
    subrr r5 r1
    movrr r3 r1
    movxr r1 r1
    movar esi r2
    movrx r1 r2
    
    ; unknown command test
    
    ; unknown command jle
    
    ; unknown command lea
    
    movmr esi r1
    movar edx r2
    movrx r1 r2
    
    ; unknown command and
    
    ; unknown command cmp
    
    ; unknown command jae
    
    ; unknown command xor
    
    movir #1 r1
    movar edi r2
    movrx r1 r2
    
    ; unknown command jmp
    
LBB2U1:
    ; unknown command xor
    
    ; unknown command jmp
    
LBB2U4:
    movmr edx r1
    movar eax r2
    movrx r1 r2
    
    ; unknown command sub
    
    ; unknown command xor
    
    movir #1 r1
    movar edi r2
    movrx r1 r2
    
LBB2U5:
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command add
    
    ; unknown command jne
    
LBB2U6:
    movmr esi r1
    movar eax r2
    movrx r1 r2
    
    ; unknown command test
    
    ; unknown command je
    
    ; unknown command neg
    
LBB2U8:
    movmr edi r1
    movar eax r2
    movrx r1 r2
    
    ; unknown command add
    
    movmr esi r1
    movar edi r2
    movrx r1 r2
    
    movmr eax r1
    movar esi r2
    movrx r1 r2
    
    ; unknown command inc
    
    ; unknown command jne
    
LBB2U9:
    movmr ecx r3
    movar LUfinalDnonUlazyUptr r4
    addrr r4 r1
    movar L2Dpb r5
    subrr r5 r1
    movrr r3 r1
    movxr r1 r1
    movar ecx r2
    movrx r1 r2
    
    movmr eax r1
    movmr ecx r3
    movrr r3 r2
    movrx r1 r2
    
    movar esi r1
    call x86pop
    movrx r0 r1
    
    movar edi r1
    call x86pop
    movrx r0 r1
    
    movar ebp r1
    call x86pop
    movrx r0 r1
    
    call x86ret
    
Un:
    .integer #5
LU.str:
    .string "hmmm"
Uhmm:
    .integer #0
LUfinalDnonUlazyUptr:
    .integer #0
programend:
    nop 

