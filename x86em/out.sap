.start x86init
labelnull: nop
; x86 general registers
eax: .integer #3
ebx: .integer #0
ecx: .integer #0
edx: .integer #0
esi: .integer #0
edi: .integer #0

; x86 special registers
esp: .integer #0
ebp: .integer #0

; x86 flags
zf: .integer #0
cf: .integer #0
of: .integer #0

; emulator binary registers (for bitwise operations)
bin1: .allocate #32
bin2: .allocate #32
bin3: .allocate #32

endl: .integer #1
    .integer #10

tobinary:
    ; r1 is the value
    ; r2 is the pointer to the bytedump
    ; r5 is a copy of r1
    ; r6 is the remainder
    ; r7 is the number of bits computed
    ; r8 is r1 / 2

    if r1 < #0
        mulir #-1 r1
    endif

    clrr r7
    movir #32 r9
    clrb r2 r9
    cmpir #0 r1
    jmpz tobinret

    addir #32 r2
biniter:
    movrr r1 r5
    divir #2 r1
    movrr r1 r8
    mulir #2 r1
    cmprr r1 r5
    movrr r8 r1
    clrr r6
    jmpne remainder1 ; if remainder is 1
    jmpz remainder0 ; if remainder is 0
remainder1:
    movir #1 r6
remainder0:
    cmpir #0 r5
    jmpz endbin
    push r6
    addir #1 r7

    jmp biniter

endbin:
    subrr r7 r2
ebiniter:
    pop r6
    movrx r6 r2
    addir #1 r2
    subir #1 r7
    cmpir #0 r7
    jmpne ebiniter
tobinret:
    ret

power:
    ; r0 a^b
    ; r1 a
    ; r2 b
    movir #1 r0
    cmpir #0 r2
    jmpz endpower
poweriter:
    mulrr r1 r0
    subir #1 r2
    cmpir #0 r2
    jmpne poweriter
endpower:
    ret

todecimal:
    ; r0 total
    ; r1 pointer to the bytedump
    ; r5 the exponent
    ; r6 digit term (n*2^x)

    addir #31 r1
    clrr r0
    clrr r5

todeciter:
    movxr r1 r6
    push r1
    push r2
    push r0
    movir #2 r1
    movrr r5 r2
    jsr power
    mulrr r0 r6

    pop r0
    pop r2
    pop r1

    addrr r6 r0    
    
    addir #1 r5
    subir #1 r1

    cmpir #32 r5
    jmpne todeciter

    ret

low16:
    ; r1 address of Nx register where N is a-d
    call tobinary *r1 &bin2

    movar bin1 r5
    movir #16 r6
    clrb r5 r6

    movar bin1 r1
    jsr todecimal
    ret

high8:
    ; r1 address of eNh register where N is a-d

    call tobinary *r1 &bin2

    movar bin1 r5
    addir #16 r5
    movrr r5 r6
    addir #8 r6
    movir #8 r7

    movb r5 r6 r7

    movar bin1 r5
    movir #24 r6
    clrb r5 r6

    movar bin1 r1
    jsr todecimal

    ret

low8:
    ; r1 address of Nl register where N is a-d
    call tobinary *r1 &bin1 

    movar bin1 r5
    movir #24 r6
    clrb r5 r6

    movar bin1 r1
    jsr todecimal
    ret

setlow16:
    ; r1 address of Nx register where N is a-d
    ; r2 is the new value

    call tobinary *r1 &bin1
    call tobinary r2 &bin2

    movar bin2 r5
    movar bin1 r6
    addir #16 r5
    addir #16 r6
    movir #16 r7
    movb r5 r6 r7

    call todecimal &bin1
    movrx r0 r1
    
    ret

setlow8:
    ; r1 address of Nx register where N is a-d
    ; r2 is the new value

    call tobinary *r1 &bin1
    call tobinary r2 &bin2

    movar bin2 r5
    movar bin1 r6
    addir #24 r5
    addir #24 r6
    movir #8 r7
    movb r5 r6 r7

    call todecimal &bin1
    movrx r0 r1
    
    ret

sethigh8:
    ; r1 address of Nx register where N is a-d
    ; r2 is the new value

    call tobinary *r1 &bin1
    call tobinary r2 &bin2

    movar bin2 r5
    movar bin1 r6
    addir #24 r5
    addir #16 r6
    movir #8 r7
    movb r5 r6 r7

    call todecimal &bin1
    movrx r0 r1
    
    ret

x86push:
    ; r1 value
    addim #1 esp
    movmr esp r4
    movrx r1 r4
    ret

x86pop:
    movmr esp r4
    movxr r4 r0
    subim #1 esp
    ret

x86ret: ; Uses code manipulation to jump to a custom location
    call x86pop
    movar retval r4
    addir #1 r4
    movrx r0 r4
retval:
    jmp labelnull

bitwiseand:
    ; r1 address of binary register
    ; r2 address of binary register
    ; r3 address of output binary register
    ; r5 offset
    ; r6 value1
    ; r7 value2
    ; r8 set value

    movir #0 r5
anditer:
    movxr r1 r6
    movxr r2 r7
    cmpir #1 r6
    jmpne andset0
    cmprr r6 r7
    jmpz andset1
    jmpne andset0
andset1:
    movir #1 r8
    jmp andnoset
andset0:
    movir #0 r8
andnoset:
    movrx r8 r3

    addir #1 r1
    addir #1 r2
    addir #1 r3
    addir #1 r5

    cmpir #32 r5
    jmpne anditer

    ret
    

Ufinal:
    .allocate #4

x86init:
    movar LUAstr r1
    movrm r1 Uhmm
    movar programend r1
    addir #100 r1
    movrm r1 esp
    movar end r2
    addir #2 r2
    call x86push r2
end:
    jmp Umain
    halt 

Uprint:
    movmr ebp r1
    call x86push r1
    
    movmr esp r1
    movar ebp r2
    movrx r1 r2
    
    movar ebp r1
    call x86pop
    movrx r0 r1
    
    call x86ret
    
Uprinti:
    movmr ebp r1
    call x86push r1
    
    movmr esp r1
    movar ebp r2
    movrx r1 r2
    
    movar ebp r1
    call x86pop
    movrx r0 r1
    
    call x86ret
    
Umain:
    movmr ebp r1
    call x86push r1
    
    movmr esp r1
    movar ebp r2
    movrx r1 r2
    
    movmr edi r1
    call x86push r1
    
    movmr esi r1
    call x86push r1
    
    push r2
    movar checkpoint0 r2
    addir #2 r2
    call x86push r2
    pop r2
checkpoint0:
    jmp L2Dpb
    
L2Dpb:
    movar ecx r1
    call x86pop
    movrx r0 r1
    
    movmr ecx r3
    movar Un r4
    addrr r4 r1
    movar L2Dpb r5
    subrr r5 r1
    movrr r3 r1
    movxr r1 r1
    movar esi r2
    movrx r1 r2
    
    movmr esi r1
    movmr esi r2
    call tobinary r1 &bin1
    call tobinary r2 &bin2
    call bitwiseand &bin1 &bin2 &bin3
    call todecimal &bin3
    clrm cf
    clrm of
    if r0 == #0
       zf = #1
    else
       zf = #0
    endif
    
    if *zf == #1
       jmp LBB2U1
    endif
    
    ; unknown command lea
    
    movmr esi r1
    movar edx r2
    movrx r1 r2
    
    ; unknown command and
    
    ; unknown command cmp
    
    ; unknown command jae
    
    ; unknown command xor
    
    movir #1 r1
    movar edi r2
    movrx r1 r2
    
    jmp LBB2U6
    
LBB2U1:
    ; unknown command xor
    
    jmp LBB2U9
    
LBB2U4:
    movmr edx r1
    movar eax r2
    movrx r1 r2
    
    ; unknown command sub
    
    ; unknown command xor
    
    movir #1 r1
    movar edi r2
    movrx r1 r2
    
LBB2U5:
    movmr edi r1
    movar esi r2
    addrx r1 r2
    
    movmr esi r1
    movar edi r2
    addrx r1 r2
    
    movmr edi r1
    movar esi r2
    addrx r1 r2
    
    movmr esi r1
    movar edi r2
    addrx r1 r2
    
    movmr edi r1
    movar esi r2
    addrx r1 r2
    
    movmr esi r1
    movar edi r2
    addrx r1 r2
    
    movmr edi r1
    movar esi r2
    addrx r1 r2
    
    movmr esi r1
    movar edi r2
    addrx r1 r2
    
    movir #8 r1
    movar eax r2
    addrx r1 r2
    
    if *zf == #0
       jmp LBB2U5
    endif
    
LBB2U6:
    movmr esi r1
    movar eax r2
    movrx r1 r2
    
    movmr edx r1
    movmr edx r2
    call tobinary r1 &bin1
    call tobinary r2 &bin2
    call bitwiseand &bin1 &bin2 &bin3
    call todecimal &bin3
    clrm cf
    clrm of
    if r0 == #0
       zf = #1
    else
       zf = #0
    endif
    
    if *zf == #1
       jmp LBB2U9
    endif
    
    ; unknown command neg
    
LBB2U8:
    movmr edi r1
    movar eax r2
    movrx r1 r2
    
    movmr edi r1
    movar esi r2
    addrx r1 r2
    
    movmr esi r1
    movar edi r2
    movrx r1 r2
    
    movmr eax r1
    movar esi r2
    movrx r1 r2
    
    ; unknown command inc
    
    if *zf == #0
       jmp LBB2U8
    endif
    
LBB2U9:
    movmr ecx r3
    movar LUfinalDnonUlazyUptr r4
    addrr r4 r1
    movar L2Dpb r5
    subrr r5 r1
    movrr r3 r1
    movxr r1 r1
    movar ecx r2
    movrx r1 r2
    
    movmr eax r1
    movmr ecx r3
    movrr r3 r2
    movrx r1 r2
    
    movar esi r1
    call x86pop
    movrx r0 r1
    
    movar edi r1
    call x86pop
    movrx r0 r1
    
    movar ebp r1
    call x86pop
    movrx r0 r1
    
    call x86ret
    
Un:
    .integer #5
LUAstr:
    .string "hmmm"
Uhmm:
    .integer #0
LUfinalDnonUlazyUptr:
    .integer #0
programend:
    nop 

