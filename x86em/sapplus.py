"""The successor to pySAP"""

import os
from subprocess import Popen, PIPE, STDOUT
from termcolor import colored
import subprocess
import sys
import json
import glob
import getpass
import re

STAMP = """; Code autogenerated by SAPplus
"""

def rcut(string, pattern):
    if string.endswith(pattern):
        return string[:-len(pattern)]
    return string

def lcut(string, pattern):
    if string.startswith(pattern):
        return string[len(pattern):]
    return string

with open("sapplus_config.json") as fl:
    config = json.load(fl)

def safe_rm(p):
    if os.path.exists(p):
        os.remove(p)

def clean_path(path):  # Stulin lazy
    if not path.endswith("/"):
        return path+"/"
    return path

def clean_output_files(project):
    safe_rm(project+".lst")
    safe_rm(project+".bin")
    safe_rm(project+".sym")


def assemble(project):
    project_dir = clean_path(os.path.dirname(project))
    project_name = os.path.basename(project)
    clean_output_files(project)

    p = subprocess.Popen([config['assembler-binary']], stdout=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)
    assembler_input = f'path {project_dir}\nasm {project_name}\nquit'
    s = p.communicate(input=bytes(assembler_input, 'utf8'))

    return p


def run(project, vm_path):
    p = subprocess.Popen([vm_path], stdin=subprocess.PIPE, shell=True)
    p.communicate(input=bytes(project+".bin\nquit", 'utf8'))

class SAPMacro:
    def __init__(self):
        self.preserve_indentation = True
        self.match = ".+"
        self.debug_comment = True
        
    def on_readline(self, line):
        pass

class CallMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "^call"

    def on_readline(self, line):
        insertion = []

        instruction = line.strip()
        subroutine = instruction.split(" ")[1]
        args = instruction.split(" ")[2:]
        
        should_pop = []

        arg_num = 1
        for arg in args:
            if arg_num == 5:
                print("SAP supports a maximum of 4 arguments to subroutines")
                exit()
            insertion.append(f"push r{arg_num}")
            if re.fullmatch("r\d+", arg): # Pass register as argument
                insertion.append(f"movrr {arg} r{arg_num}")
                
            elif arg.startswith('#'): # Pass integer constant as argument
                insertion.append(f"movir {arg} r{arg_num}")
            elif arg.startswith("*"): # Pass dereferenced value as argument
                arg = arg[1:]
                if re.match("r\d+", arg): # Pass value of pointer register
                    insertion.append(f"movrr {arg} r{arg_num}")
                else: # Pass value of label
                    insertion.append(f"movar {arg} r{arg_num}")
                insertion.append(f"movxr r{arg_num} r{arg_num}")
            elif arg.startswith("&"): # Pass pointer to label as argument
                arg = arg[1:]
                insertion.append(f"movar {arg} r{arg_num}")
            else:
                print(f"{arg} is not a valid argument. If you're passing a label, you need to pass as its address or dereference it")
                exit()
            should_pop.append(arg_num)
            arg_num+=1
        insertion.append(f"jsr {subroutine}")
        while should_pop:
            insertion.append(f"pop r{should_pop.pop()}")

        return insertion

def simple_macro_runner(insertion, argnames, args):
    insertion = insertion[:]
    for i, line in enumerate(insertion):
        for name, value in zip(argnames, args):
            insertion[i] = line.replace("$"+name, value)
            if "$"+name in line:
                break

    return insertion

class SimpleMacro(SAPMacro):
    def __init__(self, signature, insertion):
        super().__init__()
        self.insertion = insertion

        parts = signature.split(" ")
        self.name = parts[0]
        self.match = "^"+parts[0]
        self.argnames = parts[1:]

    def on_readline(self, line):
        line = line.strip()
        values = line.split(" ")[1:]
        return simple_macro_runner(self.insertion, self.argnames, values)

def simple_macro_type(signature, insertion):
    return lambda: SimpleMacro(signature, insertion)

def load_extension(json_data:str):
    macros = json.loads(json_data)
    macro_types = []

    for signature in macros:
        insertion = macros[signature]

        macro_types.append(simple_macro_type(signature, insertion))
    return macro_types

def apply_macro(T:type, _lines):
    macro = T()
    lines = _lines[:]
    for i, line in enumerate(_lines):
        if not re.match(macro.match, line.strip()):
            continue
        insertion = macro.on_readline(line)

        if macro.debug_comment:
            insertion[0] += " ; "+line.strip()

        if macro.preserve_indentation and line.lstrip()!=line:
            for j, new_line in enumerate(insertion):
                insertion[j] = "\t"+new_line.strip()
        
        lines[i] = "\n".join(insertion)

    return lines

def compress(_lines):
    lines = []
    for line in _lines:
        if line.strip().startswith(";") or line.strip() == "":
            continue

        comment = re.findall(" ?;.+$", line)
        if comment:
            line = rcut(line, comment[0])
        lines.append(line)
    return lines

def fix_empty_labels(_lines):
    lines = []
    skip = False
    for i, line in enumerate(_lines):
        if skip:
            skip = False
            continue
        if re.search(':(\s+)?$', line):
            lines.append(line.rstrip()+" "+_lines[i+1].strip())
            skip = True
        else:
            lines.append(line)
    return lines

def stamp(lines:list):
    lines.insert(0, STAMP)

def preprocess(src):
    lines = src.split("\n")
    lines = compress(lines)
    lines = apply_macro(CallMacro, lines)
    with open(config["instruction-set-extensions"]) as fl:
        ext_data = fl.read()
    for macro in load_extension(ext_data):
        lines = apply_macro(macro, lines)
    lines = fix_empty_labels(lines)

    stamp(lines)

    return "\n".join(("\n".join(lines)).split("\n"))

def get_errors(lst):
    offending_lines = re.findall(".+\n(?=\.{10})", lst)
    error_messages = re.findall(re.compile("^\.{10}.+$", re.MULTILINE), lst)
    return offending_lines, error_messages

def run_demo(argv):
    if "-h" in argv or "--help" in argv:
        print("""Use "python pySAP.py run" to also run the assembly program. Open config.json for options and more parameters. """)
        raise SystemExit

    asm_src = argv[0]
    src_project = os.path.splitext(asm_src)[0]

    vm_path = glob.glob("/Users/"+getpass.getuser()+"/Library/Developer/Xcode/DerivedData/" +
                        config["xcode-proj-name"]+"*")[0]+"/Build/Products/Debug/"+config["xcode-proj-name"]

    print(colored("\nPreprocessing...", "blue"))
    with open(asm_src) as fl:
        output = preprocess(fl.read())
    
    out_project = src_project+".expanded"
    with open(out_project+".txt", 'w') as fl:
        fl.write(output)

    print(colored("Assembling...", "blue"))
    proc = assemble(out_project)
    if proc.returncode != 0:
        print(colored("Assembler returned non-zero error code " +str(p.returncode), "red"))
        exit()
    
    if not os.path.exists(out_project+".bin"):
        print()
        with open(out_project+".lst") as fl:
            offending, msgs = get_errors(fl.read())
            for line, msg in zip(offending, msgs):
                print(colored(line.strip(), "magenta"))
                print(colored("\tError: "+msg.strip("."), "red"))
        exit()

    if 'run' in argv:
        print(colored("Running...", "blue"))
        run(out_project, vm_path)

if __name__ == "__main__":
    run_demo(sys.argv[1:])
