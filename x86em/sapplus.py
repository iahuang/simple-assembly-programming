"""The successor to pySAP"""

import os
from subprocess import Popen, PIPE, STDOUT
from termcolor import colored
import subprocess
import sys
import json
import glob
import getpass
import re

class CharacterSets:
    alpha_l = set("abcdefghijklmnopqrstuvwxyz")
    alpha_u = set("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    alpha = alpha_l.union(alpha_u)
    alpha_v = alpha.union(set("_"))
    num = set("0123456789")
    num_f = set("0123456789.")
    var = alpha.union(num).union(set("_."))
    grouping = ["()", '""', "''", "[]", "{}"]
    brackets = ["()", "[]", "{}"]


def find_type(s):
    return "function"


def parse_csv(s, separator=",", valid_grouping=CharacterSets.grouping, escape_token="\\", strip_whitespace=True):
    """ Split a string on character, ignoring escaped and grouped characters """

    assert len(separator) == 1, "Separator must be a single character"
    return parse_dsv(s, [separator], valid_grouping, escape_token, strip_whitespace)[::2]


def parse_dsv(s, separators=[","], valid_grouping=CharacterSets.grouping, escape_token="\\", strip_whitespace=True):
    """ Split a string on characters, ignoring escaped and grouped characters """

    s = group(s, valid_grouping=valid_grouping,
                      escape_token=escape_token)
    split = []
    block = ""
    for c in s:
        if c in separators:
            if strip_whitespace:
                block = block.strip()
            split.append(block)
            block = ""
            split.append(c)
        else:
            block += c
    split.append(block)

    return split


def strip_grouping(s, grouping=CharacterSets.brackets):
    """ Removes any possible forms of grouping from s """
    i = 0
    while i < len(grouping):
        opening, closing = grouping[i]
        if s.startswith(opening) and s.endswith(closing):
            i = 0  # Repeat to check for extraneous brackets (((((hmmm)))))
            s = s[1:-1]  # Remove first and last chars
        i += 1
    return s


def escape_values(s, valid_set=CharacterSets.var):
    s = group(s)

    block = ""
    string = []
    last_valid = True
    for c in s:
        if c in valid_set:
            block += c
        else:
            if block:
                string.append(block)
                block = ""
            string.append(c)
    if block:
        string.append(block)
    return string

def group_quotes(s, grouping="\"'", escape_token="\\"):
    stack = []
    block = ""
    string = []
    for c in escape(s, token=escape_token):
        if c in grouping:  # Open group
            if not stack: # Lowest level
                stack.append(c)
                block = c
            elif stack[-1] == c: # Close group
                string.append(block+c)
                stack = stack[:-1]
                block = ""
            else:
                stack.append(c)
        elif stack == []:  # Is on root nesting, and delimiter is reached
            string.append(c)
        else:
            block += c

    if block:
        string.append(block)

    return string

def group_brackets(s, valid_grouping=CharacterSets.brackets, escape_token="\\"):
    opening = {g[0]: g[1] for g in valid_grouping}
    closing = {g[1]: g[0] for g in valid_grouping}
    stack = []
    block = ""
    string = []
    for c in escape(s, token=escape_token):
        if c in opening:  # Open group ex: (
            stack.append(c)

        if c in closing:  # Close group ex: )
            if closing[c] != stack[-1]:  # Unbalanced brackets
                raise SyntaxError("Unbalanced brackets")
            stack = stack[:-1]
            block += c
            if stack == []:
                string.append(block)
                block = ""
                
        elif stack == []:  # Is on root nesting, and delimiter is reached
            string.append(c)
        else:
            block += c
    return string

def group(s,valid_grouping=CharacterSets.grouping, escape_token="\\"):
    quote_grouping = []
    bracket_grouping = []

    for g in valid_grouping:
        if g[0] == g[1]:
            quote_grouping.append(g[0])
        else:
            bracket_grouping.append(g)
    
    return group_brackets(group_quotes(s, quote_grouping, escape_token), bracket_grouping, escape_token)

def escape(s, token="\\"):
    """ Group escaped characters into one cell """
    chrs = []
    i = 0
    while i < len(s):
        c = s[i]
        if c == token:
            chrs.append(c+s[i+1])
            i += 1
        else:
            chrs.append(c)
        i += 1
    return chrs

STAMP = """; Code autogenerated by SAPplus
"""

def arg_to_register(arg, reg_num):
    insertion = []
    
    if re.fullmatch("r\d+", arg):  # Pass register as argument
        insertion.append(f"movrr {arg} r{reg_num}")

    elif arg.startswith('#'):  # Pass integer constant as argument
        insertion.append(f"movir {arg} r{reg_num}")
    elif arg.startswith("*"):  # Pass dereferenced value as argument
        arg = arg[1:]
        if re.match("r\d+", arg):  # Pass value of pointer register
            insertion.append(f"movrr {arg} r{reg_num}")
        else:  # Pass value of label
            insertion.append(f"movar {arg} r{reg_num}")
        insertion.append(f"movxr r{reg_num} r{reg_num}")
    elif arg.startswith("&"):  # Pass pointer to label as argument
        arg = arg[1:]
        insertion.append(f"movar {arg} r{reg_num}")
    else:
        print(
            f"{arg} is not a valid argument. If you're passing a label, you need to pass as its address or dereference it")
        exit()
    return insertion

def rcut(string, pattern):
    if string.endswith(pattern):
        return string[:-len(pattern)]
    return string


def lcut(string, pattern):
    if string.startswith(pattern):
        return string[len(pattern):]
    return string


with open("sapplus_config.json") as fl:
    config = json.load(fl)


def safe_rm(p):
    if os.path.exists(p):
        os.remove(p)


def clean_path(path):  # Stulin lazy
    if not path.endswith("/"):
        return path+"/"
    return path


def clean_output_files(project):
    safe_rm(project+".lst")
    safe_rm(project+".bin")
    safe_rm(project+".sym")


def assemble(project):
    project_dir = clean_path(os.path.dirname(project))
    project_name = os.path.basename(project)
    clean_output_files(project)

    p = subprocess.Popen([config['assembler-binary']],
                         stdout=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)
    assembler_input = f'path {project_dir}\nasm {project_name}\nquit'
    s = p.communicate(input=bytes(assembler_input, 'utf8'))

    return p


def run(project, vm_path):
    p = subprocess.Popen([vm_path], stdin=subprocess.PIPE, shell=True)
    p.communicate(input=bytes(project+".bin\nquit", 'utf8'))


class SAPMacro:
    def __init__(self):
        self.preserve_indentation = True
        self.match = ".+"
        self.debug_comment = True
        self.header_insertion = None

    def on_readline(self, line):
        pass


class AssignMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "\w+ ?="

    def on_readline(self, line):
        insertion = []
        parts = line.split("=")
        var = parts[0].strip()
        value = parts[1].strip()

        assign_to_reg = False
        output_reg = 1

        if re.match("r\d+", var):
            assign_to_reg = True
            output_reg = var.strip("r")
        else:
            insertion.append("push r"+str(output_reg))

        insertion+=arg_to_register(value, output_reg)

        if not assign_to_reg:
            insertion.append(f"movrm r{output_reg} {var}")
            insertion.append(f"pop r{output_reg}")
        return insertion


class PrintMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "print "
        self.str_count = 0

    def on_readline(self, line):
        self.header_insertion = []
        insertion = []

        parts = parse_dsv(line,[" "])[::2]
        args = parts[1:]

        for arg in args:
            if re.match('".+"', arg):
                tmp_label = "STRTMP"+str(self.str_count)
                self.str_count += 1

                self.header_insertion.append(f'{tmp_label}: .string {arg}')
                insertion.append("outs "+tmp_label)
            else:
                insertion.append("push r1")
                insertion+=arg_to_register(arg, 1)
                insertion.append("printi r1")
                insertion.append("pop r1")


            insertion.append("outci #32")
        insertion = insertion[:-1]
        return insertion


class PrintlnMacro(PrintMacro):
    def __init__(self):
        super().__init__()
        self.match = "println"
        self.str_count = 0

    def on_readline(self, line):
        insertion = super().on_readline(line)
        insertion.append("outci #10")
        return insertion


class CallMacro(SAPMacro):
    def __init__(self):
        super().__init__()
        self.match = "call"

    def on_readline(self, line):
        insertion = []

        instruction = line.strip()
        subroutine = instruction.split(" ")[1]
        args = instruction.split(" ")[2:]

        should_pop = []

        arg_num = 1
        for arg in args:
            if arg_num == 5:
                print("SAP supports a maximum of 4 arguments to subroutines")
                exit()
            insertion.append(f"push r{arg_num}")
            if re.fullmatch("r\d+", arg):  # Pass register as argument
                insertion.append(f"movrr {arg} r{arg_num}")

            elif arg.startswith('#'):  # Pass integer constant as argument
                insertion.append(f"movir {arg} r{arg_num}")
            elif arg.startswith("*"):  # Pass dereferenced value as argument
                arg = arg[1:]
                if re.match("r\d+", arg):  # Pass value of pointer register
                    insertion.append(f"movrr {arg} r{arg_num}")
                else:  # Pass value of label
                    insertion.append(f"movar {arg} r{arg_num}")
                insertion.append(f"movxr r{arg_num} r{arg_num}")
            elif arg.startswith("&"):  # Pass pointer to label as argument
                arg = arg[1:]
                insertion.append(f"movar {arg} r{arg_num}")
            else:
                print(
                    f"{arg} is not a valid argument. If you're passing a label, you need to pass as its address or dereference it")
                exit()
            should_pop.append(arg_num)
            arg_num += 1
        insertion.append(f"jsr {subroutine}")
        while should_pop:
            insertion.append(f"pop r{should_pop.pop()}")

        return insertion


def simple_macro_runner(insertion, argnames, args):
    insertion = insertion[:]
    for i, line in enumerate(insertion):
        for name, value in zip(argnames, args):
            insertion[i] = line.replace("$"+name, value)
            if "$"+name in line:
                break

    return insertion


class SimpleMacro(SAPMacro):
    def __init__(self, signature, insertion):
        super().__init__()
        self.insertion = insertion

        parts = signature.split(" ")
        self.name = parts[0]
        self.match = parts[0]
        self.argnames = parts[1:]

    def on_readline(self, line):
        line = line.strip()
        values = line.split(" ")[1:]
        return simple_macro_runner(self.insertion, self.argnames, values)


def simple_macro_type(signature, insertion):
    return lambda: SimpleMacro(signature, insertion)


def load_extension(json_data: str):
    macros = json.loads(json_data)
    macro_types = []

    for signature in macros:
        insertion = macros[signature]

        macro_types.append(simple_macro_type(signature, insertion))
    return macro_types


def apply_macro(T: type, _lines):
    macro = T()
    header = []
    lines = _lines[:]
    for i, line in enumerate(_lines):
        if not re.match(macro.match, line.strip()):
            continue

        insertion = macro.on_readline(line.strip())

        if macro.header_insertion:
            header += macro.header_insertion

        if macro.debug_comment:
            insertion[0] += " ; "+line.strip()

        if macro.preserve_indentation and line.lstrip() != line:
            for j, new_line in enumerate(insertion):
                insertion[j] = "    "+new_line.strip()

        lines[i] = "\n".join(insertion)

    return header+lines


def compress(_lines):
    lines = []
    for line in _lines:
        if line.strip().startswith(";") or line.strip() == "":
            continue

        comment = re.findall(" ?;.+$", line)
        if comment:
            line = rcut(line, comment[0])
        lines.append(line)
    return lines


def fix_empty_labels(_lines):
    lines = []
    skip = False
    for i, line in enumerate(_lines):
        if skip:
            skip = False
            continue
        if re.search(':(\s+)?$', line):
            lines.append(line.rstrip()+" "+_lines[i+1].strip())
            skip = True
        else:
            lines.append(line)
    return lines


def stamp(lines: list):
    lines.insert(0, STAMP)

def compare_args(a, b):
    insertion = []
    insertion.append("push r1")
    insertion.append("push r2")
    insertion+=arg_to_register(a, 1)
    insertion+=arg_to_register(b, 2)
    insertion.append("cmprr r1 r2")
    insertion.append("pop r2")
    insertion.append("pop r1")
    return insertion

class Branch:
    def __init__(self):
        self.condition = None
        self.blocks = []
    def add_block(self, b):
        self.blocks.append(b)

def parse_if_chunks(_lines):
    chunks = []
    branch = Branch()
    bnblock = []
    nest = 0
    for line in _lines:
        if nest == 1:
            if line.strip().startswith("else"):
                branch.add_block(bnblock)
                bnblock = []
                # [None]
                # if line.strip().startswith("else if "):
                #     bnblock[0] = line
                
            elif line.strip().startswith("endif"):
                branch.add_block(bnblock)
                bnblock = []
            else:
                bnblock.append(line)
        if nest > 1:
            bnblock.append(line)

        if line.strip().startswith("if "):
            nest+=1
            if nest == 1:
                branch.condition = line
        if line.strip().startswith("endif"):
            nest-=1
            
            if nest == 0:
                chunks.append(branch)
                branch = Branch()
        elif nest == 0:
            chunks.append(line)
    return chunks

def convert_ifs(_lines, prefix=""):
    chunks = parse_if_chunks(_lines)
    lines = []
    branch_id = 0
    for chunk in chunks:
        if isinstance(chunk, Branch):
            condition = lcut(chunk.condition.strip(),"if").replace(" ", "")
            ops = ("==", ">", "<", "!=")
            
            parts = None
            for op in ops:
                if op in condition:
                    a,b = condition.split(op)
                    break
            
            iflabel = "bnIF"+prefix+str(branch_id)
            elselabel = "bnELSE"+prefix+str(branch_id)
            endiflabel = "bnEND"+prefix+str(branch_id)

            insertion = compare_args(a,b)
            if op == "==":
                insertion.append("jmpz "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == "!=":
                insertion.append("jmpne "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == ">":
                insertion.append("jmpn "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == "<":
                insertion.append("jmpp "+iflabel)
                insertion.append("jmp "+elselabel)
            elif op == ">=":
                insertion.append("jmpp "+elselabel)
                insertion.append("jmp "+iflabel)
            elif op == "<=":
                insertion.append("jmpn "+elselabel)
                insertion.append("jmp "+iflabel)
            else:
                print("Invalid operation",op)
                exit()
            
            insertion.append(iflabel+":")
            insertion+=convert_ifs(chunk.blocks[0], prefix+"Nest")
            insertion.append("jmp "+endiflabel)
            if len(chunk.blocks) > 1:
                insertion.append(elselabel+":")
                insertion+=convert_ifs(chunk.blocks[1], prefix+"Nest")
            else:
                insertion.append(elselabel+": nop")
            insertion.append(endiflabel+": nop")
            lines+=insertion
            branch_id+=1
        else:
            lines.append(chunk)
    return lines


def preprocess(src):
    lines = src.split("\n")
    lines = compress(lines)
    lines = apply_macro(AssignMacro, lines)
    lines = apply_macro(CallMacro, lines)
    lines = apply_macro(PrintMacro, lines)
    lines = apply_macro(PrintlnMacro, lines)
    with open(config["instruction-set-extensions"]) as fl:
        ext_data = fl.read()
    for macro in load_extension(ext_data):
        lines = apply_macro(macro, lines)
    lines = convert_ifs(lines)
    lines = fix_empty_labels(lines)
    
    stamp(lines)

    return "\n".join(("\n".join(lines)).split("\n"))


def get_errors(lst):
    offending_lines = re.findall(".+\n(?=\.{10})", lst)
    error_messages = re.findall(re.compile("^\.{10}.+$", re.MULTILINE), lst)
    return offending_lines, error_messages


def run_demo(argv):
    if "-h" in argv or "--help" in argv:
        print("""Use "python pySAP.py run" to also run the assembly program. Open config.json for options and more parameters. """)
        raise SystemExit

    asm_src = argv[0]
    src_project = os.path.splitext(asm_src)[0]

    vm_path = glob.glob("/Users/"+getpass.getuser()+"/Library/Developer/Xcode/DerivedData/" +
                        config["xcode-proj-name"]+"*")[0]+"/Build/Products/Debug/"+config["xcode-proj-name"]

    print(colored("\nPreprocessing...", "blue"))
    with open(asm_src) as fl:
        output = preprocess(fl.read())

    out_project = src_project+".expanded"
    with open(out_project+".txt", 'w') as fl:
        fl.write(output)

    print(colored("Assembling...", "blue"))
    proc = assemble(out_project)
    if proc.returncode != 0:
        print(colored("Assembler returned non-zero error code " +
                      str(p.returncode), "red"))
        exit()

    if not os.path.exists(out_project+".bin"):
        print()
        with open(out_project+".lst") as fl:
            offending, msgs = get_errors(fl.read())
            for line, msg in zip(offending, msgs):
                print(colored(line.strip(), "magenta"))
                print(colored("\tError: "+msg.strip("."), "red"))
        exit()

    if 'run' in argv:
        print(colored("Running...", "blue"))
        run(out_project, vm_path)


if __name__ == "__main__":
    run_demo(sys.argv[1:])
